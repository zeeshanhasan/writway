---
description:
globs:
alwaysApply: true
---

# Backend Guidelines

Authoritative rules for the Node.js API layer used by WritWay. These rules are binding for Cursor-generated code and human contributions.

---

## 0) Scope & Goals

* **Scope**: Backend service(s) written in Node.js exposing a standardized REST API consumed by our Next.js frontend and (later) external partners.
* **Goals**: Predictable APIs, zero duplication, strong security, testability, observability, and safe integrations.

---

## 1) Tech & Runtime

* **Runtime**: Node.js (latest LTS) on Vercel Serverless Functions
* **Framework**: Express (wrapped via `serverless-http`) or native handlers
* **ORM**: Prisma (PostgreSQL via Supabase; pooled connections recommended)
* **Validation**: Zod
* **Docs**: OpenAPI 3.0+ (Swagger UI served at `/api/docs` in non‑prod)
* **Testing**: Jest + Supertest (integration)
* **Queues / Jobs**: BullMQ (Redis) for async + scheduled work
* **Env**: 12‑factor config via `.env` and process.env

### 1.1 Deployment & Domains
* **Platform**: Vercel-only deployments
* **Prod Domains**: API served at `https://api.writway.com`
* **Routing**: All HTTP routes mounted under `/api/v1` within Vercel functions (`/api/*`)
* **Do not** run migrations at build or request time. See DevOps rules.

### 1.2 Serverless Health & DB Checks (Vercel + Supabase)
* **Database**: Supabase PostgreSQL exclusively. Always use pooled connection strings for serverless.
* **Health probes**: Use lightweight `pg` client, NEVER Prisma in serverless health/ready endpoints. Prisma engines are heavyweight for cold starts and may fail inside short-lived functions.
* **Connection strings**:
  - `DATABASE_URL`: Pooled via pgBouncer (`:6543/postgres?pgbouncer=true&connection_limit=1&sslmode=require`)
  - `DIRECT_DATABASE_URL`: Direct connection (`:5432`) for migrations in CI ONLY; never at runtime.
* **Prepared statements**: Set `PRISMA_DISABLE_PREPARED_STATEMENTS=true` in Vercel env vars.
* **Health endpoint**: Return 200 with `{ success: true, data: {...}, error: null }` on success.
* **Ready endpoint**: Return 503 with `{ success: false, data: null, error: {...} }` on DB failure.
* For table listings in health, query `information_schema.tables` and exclude `_prisma_migrations`.
* Keep logs minimal and never print secrets; log only error messages.

### 1.3 Language & File Standards
* **TypeScript only**: All files under `/backend/src` and `/backend/api` must be `.ts` or `.tsx`.
* **No JavaScript**: No `.js` files in source directories. Seed scripts and one-off tools may use JS if documented.
* **Type safety**: Enable `strict: true` in tsconfig.json. No `any` types except in serverless handler signatures.

### 1.4 Vercel Deployment Configuration & File Structure

**CRITICAL: Vercel Serverless Function Rules**

Vercel maps file paths in `/api` directory directly to URL routes:
- `api/v1/health.ts` → `/api/v1/health` endpoint
- `api/v1/auth/google.ts` → `/api/v1/auth/google` endpoint
- `api/v1/auth/callback.ts` → `/api/v1/auth/callback` endpoint

**File Structure Requirements:**
* Each TypeScript file in `/backend/api/**/*.ts` becomes a standalone serverless function
* File path MUST match the desired URL path exactly
* Each file must export a default function: `export default async function handler(req, res) { }`
* Do NOT use catch-all routes like `[...path].ts` - they don't work reliably with Express apps
* Do NOT try to route everything through a single Express app in `api/index.ts`
* **NEVER use Express wrapper for individual endpoints** - Vercel serverless functions work best standalone

**Individual Serverless Functions (REQUIRED PATTERN):**
```typescript
// api/v1/health.ts
export default async function handler(_req: any, res: any) {
  try {
    return res.status(200).json({ 
      success: true, 
      data: { 
        status: 'ok', 
        uptime: process.uptime(),
        timestamp: new Date().toISOString(),
        version: 'v1.0.2-standalone'
      }, 
      error: null 
    });
  } catch (error) {
    return res.status(500).json({
      success: false,
      data: null,
      error: {
        code: 'INTERNAL_ERROR',
        message: error instanceof Error ? error.message : 'Unknown error'
      }
    });
  }
}
```

**Importing from Compiled Code:**
When serverless functions need to use shared utilities (Prisma, services), they must import from the **compiled `dist/` folder**:

```typescript
// api/v1/auth/callback.ts
export default async function handler(req: any, res: any) {
  // Load modules at runtime from compiled code
  // Path is relative to backend/api/v1/auth/ → backend/dist/
  const { prisma } = require('../../../dist/config/prisma.js');
  const { authService } = require('../../../dist/services/auth.service.js');
  
  // ... rest of handler logic
}
```

**Import Path Rules:**
* From `api/v1/auth/*.ts` → use `../../../dist/` (3 levels up)
* From `api/v1/*.ts` → use `../../dist/` (2 levels up)
* From `api/*.ts` → use `../dist/` (1 level up)
* Always use `.js` extension (TypeScript compiles to JS)
* Use `require()` not `import` for runtime loading

**Vercel Configuration (`vercel.json`):**
```json
{
  "buildCommand": "npx prisma generate && npm run build",
  "installCommand": "npm install",
  "env": {
    "PRISMA_DISABLE_PREPARED_STATEMENTS": "true"
  }
}
```

**IMPORTANT: `.vercelignore` File:**
```
node_modules
.env
.env.local
*.log
.DS_Store
coverage
```

**DO NOT ignore `dist/` folder** - compiled code must be included in deployment!

**Project Setup:**
* Separate Vercel project for backend at `api.writway.com`
* Vercel Root Directory: `backend` (set in project settings)
* Runtime: Auto-detected from package.json (Node.js 20.x)
* Regions: Deploy to `iad1` (US East) or closest to Supabase region
* Build command: `npx prisma generate && npm run build`
* Environment variables: Set ALL required vars in Vercel dashboard (see §15.1)
* No migrations at build time: Migrations run via GitHub Actions before deploy

**Common Pitfalls (AVOID):**
* ❌ Using `api/[...path].ts` catch-all routes with Express apps
* ❌ Trying to mount Express app at `api/index.ts` to handle all routes
* ❌ Using `import` statements for runtime module loading (use `require()`)
* ❌ Wrong import paths (must account for Vercel's deployment structure)
* ❌ Including `dist/` in `.vercelignore` (compiled code won't deploy)
* ❌ Using `import * as passport from 'passport'` (use `import passport from 'passport'`)
* ❌ Forgetting to run `npx prisma generate` before `npm run build`

**Correct Pattern:**
* ✅ One file per endpoint: `api/v1/health.ts`, `api/v1/auth/google.ts`, etc.
* ✅ Each file is self-contained with runtime imports via `require()`
* ✅ Import from compiled `dist/` folder with correct relative paths
* ✅ Use standard response envelope in every function
* ✅ Proper error handling and logging in each function
* ✅ Test locally with `NODE_ENV=production node -e "require('./dist/config/prisma.js')"`

---

## 2) Folder Structure & Layering

```
/backend
  /src
    /api            # HTTP layer: routers/controllers only
    /services       # business logic (no HTTP or DB primitives)
    /repositories   # Prisma data mappers, one per aggregate
    /integrations   # 3P clients (OpenAI, Google, Stripe, S3, …)
    /webhooks       # inbound/outbound webhook handlers
    /jobs           # BullMQ processors, schedulers
    /middlewares    # auth, rbac, validation, rate-limit, logging
    /schemas        # zod schemas (request/response contracts)
    /utils          # shared helpers (id, dates, errors, etc.)
  /tests            # unit + integration + contract tests
  /config           # env schema, config loaders
```

**Strict boundaries**

* Controllers: parse/validate → call service → map result → respond.
* Services: business logic → call repositories/integrations.
* Repositories: *only* Prisma access. No business rules.
* No controller may call a repository directly.

---

## 3) API Design Conventions

* **Base path & version**: `/api/v1` (future versions: `/api/v2`, etc.)
* **Resources**: plural nouns (`/clients`, `/cases`, `/workflows`).
* **IDs**: path param for single resource (`/clients/{id}`).
* **Filtering**: query params; support `page`, `limit`, `sort`, `order`, and domain filters (`status`, `from`, `to`, etc.).
* **Idempotency**: `PUT` for updates (full/partial with PATCH allowed), `POST` creates, `DELETE` deletes. For mutation endpoints that may be retried by clients, accept header `Idempotency-Key` and de‑duplicate server‑side.
* **No duplicate APIs**: prefer capability via query params, not new near-duplicate routes. New routes must be reviewed against existing ones.

### 3.1 Standard Response Envelope (MANDATORY)

ALL responses must use this exact structure:

**Success:**
```json
{ "success": true, "data": { ... }, "error": null, "meta": { ... } }
```

**Error:**
```json
{ "success": false, "data": null, "error": { "code": "ERROR_CODE", "message": "Human readable", "details": {...} } }
```

* The `meta` field is optional and used for pagination.
* NEVER return success without the envelope.
* NEVER return errors outside this envelope.
* HTTP status codes: 2xx for success, 4xx for client errors, 5xx for server errors.
* Envelope structure still uses `success: true/false` regardless of HTTP status.
* **Error codes registry** lives in `/src/utils/errors.ts` and must be reused.

### 3.2 Pagination & Sorting

* Default `limit=20`, max `limit=100` unless documented otherwise.
* Return `meta.total`, `meta.page`, `meta.limit`.
* Cursor pagination is permitted for heavy lists (document clearly).

### 3.3 OpenAPI Contract

* Every route **must** be described in OpenAPI (request schema, response schema, examples, error cases).
* CI validates code ↔ spec parity; contract tests fail the build on drift.

---

## 4) Authentication & Authorization

* **Auth Flow**: Google OAuth2 → backend issues JWT access token + refresh token.
* **Stateless only**: No express-session, no server-side sessions. JWT verification on every request.
* **Token storage**: Frontend stores tokens in httpOnly cookies or localStorage (document which).
* **Refresh tokens**: Rotate on refresh; store hashed in DB with expiry. Revoke on logout.
* **JWT claims**: Include `{ userId, tenantId, role, iat, exp }`.
* **RBAC**: Middleware enforces roles: `SUPER_ADMIN`, `OWNER`, `ADMIN`, `USER`.
* **Tenant isolation**: All DB queries auto-scoped by `tenant_id` via Prisma middleware.
* **Cookie config** (if used): `domain=.writway.com`, `Secure`, `HttpOnly`, `SameSite=Lax`.

---

## 5) Validation & Security

* **Edge validation**: all inputs validated via Zod/Joi in controllers.
* **Sanitization**: escape/strip dangerous content; never trust user HTML.
* **Headers**: Helmet, CORS allowlist per environment.
* **CORS**: Production allowlist `https://writway.com`; dev allow `http://localhost:3000`.
* **Rate limiting**: global + per‑route via middleware; stricter for mutation routes.
* **Secrets**: loaded from env; never logged; rotate regularly.
* **PII/Legal**: minimize logging of PII, support data redaction, implement data retention windows.
* **Audit log**: record critical actions (who/what/when/tenant) for compliance.

---

## 6) Errors, Logging, Observability

* **Central error handler** maps known errors → standard envelope; hides stack traces in production.
* **Structured logs (JSON)**: include `requestId`, `tenantId`, `userId`, `route`, and `durationMs`.
* **Correlation**: propagate `X-Request-Id`; generate if missing.
* **Health endpoints**: `/health` (process, uptime), `/ready` (deps: DB, Redis, external touch if needed).
* **Metrics**: request rate, latency p95/p99, error rate, queue depths, external API timings; export Prometheus where applicable.

---

## 7) Database Access & Schema Rules

* **ORM**: Prisma only in repositories; no raw SQL unless justified and reviewed.
* **Database**: Supabase PostgreSQL with pgBouncer pooling.
* **Primary keys**: DB-generated UUIDs using `@db.Uuid @default(dbgenerated("gen_random_uuid()"))`.
* **No cuid()**: Never use `@default(cuid())` or `@default(uuid())`. Always DB-generated.
* **Column naming**: `snake_case` for all columns; `tenant_id`, `user_id`, etc.
* **Table naming**: Plural `snake_case` (e.g., `users`, `tenants`, `plans`).
* **Multi‑tenancy**: mandatory `tenant_id` on isolated tables. Prisma middleware MUST inject `tenant_id` filter on all tenant-scoped queries.
* **Timestamps**: Every table has `created_at` and `updated_at` (Prisma `@default(now())` and `@updatedAt`).
* **Transactions**: wrap related writes in `prisma.$transaction`.
* **Migrations**: exclusively via `prisma migrate` in CI/CD (GitHub Actions). Never in Vercel build or at request time.
* **Connections**: Use Supabase pooled connections (pgBouncer) or Prisma Accelerate for serverless.

---

## 8) Testing Strategy

* **Unit**: services, utils. Target ≥80% critical path coverage.
* **Integration**: API routes with Supertest against an ephemeral DB.
* **Contract**: schemas validated against OpenAPI; generate client SDK and verify types.
* **Mocks**: external APIs (Google, Stripe, OpenAI, S3) must be mocked; record/replay allowed in CI.

---

## 9) Third‑Party Integrations (Design Rules)

* All integrations implemented under `/src/integrations/{provider}` with a **common client interface**:

  * **Timeouts**: hard timeouts per call (e.g., 10s default; override per provider)
  * **Retries**: exponential backoff on retryable errors (network, 429/5xx)
  * **Circuit breaker**: open after N consecutive failures; short‑circuit for cool‑down
  * **Idempotency**: use provider idempotency keys where supported
  * **Request/Response logging**: log metadata only (no secrets / sensitive payloads)
  * **Cost/usage metering**: emit metrics (tokens used, calls, cost estimates)
* **Providers in scope (initial)**: Google (Gmail), Stripe, S3/equivalent, OpenAI (future), others via the same pattern.
* **Key management**: credentials via env/secrets manager; scoped with least privilege; never exposed to clients.

---

## 10) Webhooks (Inbound & Outbound)

### 10.1 Inbound Webhooks (e.g., Stripe, Google)

Pipeline:

1. **Ingress** endpoint verifies **signature** (HMAC/shared secret) and **content‑type**.
2. Compute a **dedupe key** (event id + provider) → check/store in idempotency table.
3. **Enqueue** processing job (BullMQ) with payload; return 2xx quickly.
4. Job processor performs business logic inside a transaction.
5. Handle **retries** safely; jobs must be idempotent.
6. Expose a **replay** admin function for recovery.

### 10.2 Outbound Webhooks (notify tenant systems)

* **Subscription model**: tenants can register endpoints + event types.
* **Signing**: sign payloads with tenant‑specific secret (HMAC SHA‑256). Include `X-Writway-Signature` and timestamp.
* **Delivery**: queue + retry with backoff; mark permanently failed after N attempts; dashboard for status.
* **Schema**: versioned payloads; include `eventId`, `eventType`, `occurredAt`, `data`.

---

## 11) Public API for Partners (Future‑Ready)

* **Auth**: API keys or OAuth2 Client Credentials per partner app.
* **Scopes**: fine‑grained, tenant‑scoped permissions.
* **Rate limits**: per key; communicate via `X‑RateLimit-*` headers.
* **Versioning**: `/api/v1` with deprecation policy (see §12).
* **Docs & SDKs**: publish OpenAPI; generate TS/JS SDK; provide Postman collection.

---

## 12) Versioning & Deprecation Policy

* **Semantic versioning** of API surface via URL (`/api/v{n}`).
* **Breaking changes** → new version; never silently break v1.
* **Deprecation**: provide `Sunset` header + changelog + migration guide; maintain old version for a defined window (e.g., 6–12 months) before removal.

---

## 13) Performance & Caching

* **N+1 avoidance**: use Prisma includes/selects; batch where sensible.
* **Caching**: Redis for hot reads; cache keys include `tenant_id`.
* **ETag/Last‑Modified** for GETs where feasible; support conditional requests.
* **Bulk endpoints** for high‑latency patterns to reduce chatty clients.

---

## 14) Cost Controls (AI & External APIs)

* Per‑tenant quotas and budgets for costly providers (e.g., OpenAI).
* Soft/hard limits with graceful degradation (queue, throttle, or return 429 with `Retry‑After`).
* Emit cost metrics; nightly rollups per tenant and per feature.

---

## 15) Developer Experience

* **Local**: seed scripts, docker‑compose for DB/Redis, `.env.example` kept up‑to‑date.
* **Docs**: `/api/docs` (Swagger UI) in non‑prod; publish OpenAPI JSON in all envs.
* **API Explorer**: optional lightweight explorer for authenticated users in staging.
* **Postman**: maintained collection synced with OpenAPI.

### 15.1 Environment Variables & Configuration

* **Required file**: `/backend/.env.example` with ALL required variables documented.
* **Validation**: Load and validate env vars on startup; fail fast if missing critical vars.
* **Required vars**:
  - `NODE_ENV` (development|staging|production)
  - `DATABASE_URL` (pooled Supabase connection)
  - `DIRECT_DATABASE_URL` (for CI migrations only)
  - `JWT_SECRET` (strong random string)
  - `JWT_REFRESH_SECRET` (separate secret for refresh tokens)
  - `CORS_ORIGIN` (comma-separated allowed origins)
  - `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET`, `GOOGLE_CALLBACK_URL`
  - `STRIPE_SECRET_KEY`, `STRIPE_WEBHOOK_SECRET`
  - `PRISMA_DISABLE_PREPARED_STATEMENTS=true` (for Vercel serverless)
* **Secrets**: Never log or expose in responses. Use env vars or secret manager.

---

## 16) Definition of Done (for any API story)

1. Routes implemented with validation and RBAC.
2. Service + repository logic tested (unit) and route tested (integration).
3. OpenAPI updated; examples included.
4. Error codes reused; responses conform to envelope.
5. Rate limiting configured (default or custom).
6. Logs/metrics added for critical paths.
7. Migration (if any) added and tested.
8. Changelog entry + brief developer notes.

---

## 17) Linked Rule Documents

* **Architecture overview** → `architecture.mdc`
* **Database schema & migrations** → `database.mdc`
* **Frontend consumption** → `frontend.mdc`
* **UI components** → `ui.mdc`
* **DevOps/Environments** → `devops.mdc`

---

## 18) Anti‑Patterns to Avoid

* Controllers doing business logic or DB access.
* Inconsistent response shapes or error codes.
* Unversioned routes or silent breaking changes.
* Fire‑and‑forget webhook handling without dedupe/retry.
* Leaking PII in logs; logging secrets.
* Skipping tests or OpenAPI updates.
* Creating near‑duplicate endpoints instead of adding filters/params.

---

> **Reminder**: Treat the API as a product. Predictability > cleverness. Backwards compatibility is a feature.
