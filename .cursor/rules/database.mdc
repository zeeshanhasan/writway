---
alwaysApply: true
---
# Database Guidelines
Authoritative rules for PostgreSQL + Prisma database design in WritWay. These conventions prevent schema drift, enforce multi-tenancy, and ensure long-term maintainability.

---

## 0) Scope & Goals

* **Scope**: All PostgreSQL schemas managed via Prisma ORM, hosted on Supabase in all environments.
* **Goals**: Consistent naming, safe migrations, secure multi-tenancy, and a living schema doc for clarity.

---

## 1) General Principles

* **Relational first**: design with normalized tables; denormalize only when justified by performance.
* **UUID everywhere**: all primary keys use `UUID` (generated in DB). Never `SERIAL`.
* **Timestamps**: all tables have `created_at TIMESTAMPTZ NOT NULL DEFAULT now()` and `updated_at TIMESTAMPTZ NOT NULL` (updated via trigger or Prisma hook).
* **Soft deletes**: use `deleted_at TIMESTAMPTZ NULL` where records may be logically removed but need audit trail.
* **Audit log**: maintain a separate `audit_log` table for compliance-critical actions.

---

## 2) Naming Conventions

* **Tables**: plural `snake_case` (e.g., `clients`, `cases`, `workflow_tasks`).
* **Columns**: `snake_case` (e.g., `first_name`, `tenant_id`).
* **Primary keys**: always `id UUID PRIMARY KEY`.
* **Foreign keys**: `{table}_id` (e.g., `client_id`).
* **Join tables**: `{table1}_{table2}` alphabetical order (e.g., `cases_users`).
* **Enums**: `snake_case`, suffix `_type` (e.g., `workflow_status_type`).

---

## 3) Multi-Tenancy Rules

* All tenant-scoped tables **must** include a `tenant_id UUID NOT NULL`.
* Prisma middleware automatically injects `tenant_id` filter into queries.
* Only Super Admin role can query across tenants.
* Tenant IDs indexed for fast filtering.

---

## 4) Keys, Indexes & Constraints

* **Primary key**: UUID.
* **Foreign keys**: ON DELETE CASCADE unless historical data must remain.
* **Unique constraints**: for natural keys (e.g., `email`, `external_id`).
* **Indexes**: always index `tenant_id`, foreign keys, and high-cardinality query columns (`status`, `email`).
* **Composite indexes**: use when queries involve multi-column filters (e.g., `(tenant_id, email)`).

---

## 5) Relationships

* 1:Many → foreign key in child table (e.g., `cases.client_id`).
* Many:Many → dedicated join table with two FKs + composite PK.
* Avoid implicit many-to-many in Prisma; always define join table explicitly for clarity + audit.

---

## 6) Migrations

* **Tool**: Prisma migrate exclusively.
* **Process**: generate migration → review in PR → apply in staging → apply in production via CI/CD (GitHub Actions).
* **Prohibited**: manual `psql` schema edits in production; running migrations from Vercel builds or functions.
* **Deprecations**: never drop a column directly. Steps:

  1. Mark as deprecated in schema.
  2. Migrate to new column.
  3. Remove old column in a future migration.
* **Rollback**: every migration must support rollback.

---

## 7) Seeding

* **Mandatory seeds**:

  * Roles (`SUPER_ADMIN`, `ORG_ADMIN`, `STAFF`/`USER`).
  * Super Admin bootstrap account.
  * Default pipeline stages (`Intake`, `Active`, `Closed`).
* **Optional seeds**: test/demo data for development.
* Seeds live in `/prisma/seed.ts` and run via `prisma db seed`.

---

## 8) Schema Documentation

* Maintain a separate `database_schema.mdc` (in `.cursor/rules/`) as a **living document** and source of truth.
* `database_schema.mdc` must:

  * List all tables, columns, and relationships.
  * Show ER diagrams (generate from Prisma ERD tools).
  * Be updated with every migration.
* CI rule: Any change to Prisma models requires updating `database_schema.mdc` in the same PR; builds fail on drift.

---

## 9) Data Protection & Compliance

* Store PII (e.g., names, emails) in normalized tables. Supabase at-rest encryption enabled by default.
## 12) Supabase-Specific Guidance

* Prefer pooled connection strings (pgBouncer) for serverless. Example: `...:6543/postgres?pgbouncer=true&connection_limit=1`.
* Rotate credentials via Supabase dashboard and GitHub Secrets; never commit.
* Local development should target a dev/staging Supabase project. Do not point local dev writes at production.
* If read-only access to prod is required for debugging, provision a limited role and restrict IPs.
* Encrypt sensitive fields (at application layer if required).
* Enable **pgcrypto** if DB-level encryption is required later.
* Apply data retention rules (auto-delete data past policy).
* All access must be logged in `audit_log`.

---

## 10) Anti-Patterns to Avoid

* Using auto-incrementing IDs (`SERIAL`/`BIGSERIAL`).
* Tenant data without `tenant_id`.
* Direct joins across tenants.
* Manual prod migrations.
* Implicit many-to-many relations.
* Dropping columns without migration path.

---

## 11) Linked Rule Documents

* **Architecture overview** → `architecture.mdc`
* **Backend service rules** → `backend.mdc`
* **Schema definition** → `schema.mdc`
* **DevOps (migrations, CI/CD)** → `devops.mdc`

---

> **Reminder**: The database is the system of record. Stability, consistency, and clarity outweigh clever optimizations.
